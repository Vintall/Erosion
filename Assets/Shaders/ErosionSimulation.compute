// SimultaneousErosionArray.compute
#pragma kernel CSMain

// Height map represented as a 2D array
RWStructuredBuffer<float> heightMap;

// Simulation parameters
int mapWidth;
int mapHeight;
float deltaTime = 0.1;
float erosionRate = 0.5;
float depositionRate = 0.02;
float evaporationRate = 0.01;
float minSlope = 0.01;

// Structured buffer to hold water levels
RWStructuredBuffer<float> waterMap;

float GetHeight(int2 pos)
{
    return heightMap[pos.y * mapWidth + pos.x];
}

void SetHeight(int2 pos, float value)
{
    heightMap[pos.y * mapWidth + pos.x] = value;
}

float GetWater(int2 pos)
{
    return waterMap[pos.y * mapWidth + pos.x];
}

void SetWater(int2 pos, float value)
{
    waterMap[pos.y * mapWidth + pos.x] = value;
}

bool IsInBounds(int2 pos)
{
    return pos.x >= 0 && pos.y >= 0 && pos.x < mapWidth && pos.y < mapHeight;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get 2D position of the current thread
    int2 pos = int2(id.xy);
    if (pos.x >= mapWidth || pos.y >= mapHeight)
        return; // Out-of-bounds check

    // Get height and water level at the current position
    float height = GetHeight(pos);
    float water = GetWater(pos);

    // Accumulate sediment to erode based on slope difference with neighbors
    //float sediment = 0.0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            if (x == 0 && y == 0) continue; // Skip the current cell

            int2 neighborPos = pos + int2(x, y);
            if (IsInBounds(neighborPos))
            {
                float neighborHeight = GetHeight(neighborPos);
                float slope = height - neighborHeight;

                if (slope > minSlope)
                {
                    float erosionAmount = erosionRate * slope;
                    //sediment += erosionAmount;
                    height -= erosionAmount;
                }
            }
        }
    }

    float deposit = water * depositionRate;
    //height += deposit;

    SetHeight(pos, height);
    SetWater(pos, water * (1.0 - evaporationRate));
}


