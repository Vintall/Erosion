#pragma kernel CSMain

struct VertexState
{
    float height;
    float water;
    float sediment;
};

StructuredBuffer<VertexState> inVertexStates;
RWStructuredBuffer<VertexState> outVertexStates;

int mapWidth;
int mapHeight;
float erosionRate;
float depositionRate;
float evaporationRate;
float sedimentCarryingCapacity;
float soilSoftness;
float minSlope;

VertexState GetState(int2 pos)
{
    return inVertexStates[pos.y * mapWidth + pos.x];
}

void SetState(int2 pos, VertexState value)
{
    outVertexStates[pos.y * mapWidth + pos.x] = value;
}

bool IsInBounds(int2 pos)
{
    return pos.x >= 0 && pos.y >= 0 && pos.x < mapWidth && pos.y < mapHeight;
}

VertexState NeighborInteraction(float neighborCoef, VertexState currentState, int2 currentPos, int2 neighborPos)
{
    VertexState neighborState = GetState(neighborPos);

    float deltaWater = min(currentState.water,
    ((currentState.water + currentState.height) -
    (neighborState.water + neighborState.height) ) * neighborCoef);

    if(deltaWater <= 0)
    {
        float deltaHeight = depositionRate * currentState.sediment;

        currentState.height += deltaHeight;
        currentState.sediment -= deltaHeight;

    }
    else
    {
        currentState.water -= deltaWater;
        neighborState.water += deltaWater;

        float c = deltaWater * sedimentCarryingCapacity;

        if(currentState.sediment > c)
        {
            neighborState.sediment += c;
            currentState.height += erosionRate * (currentState.sediment - c);
            currentState.sediment = (1 - erosionRate) * (currentState.sediment - c);
        }
        else
        {
            neighborState.sediment += currentState.sediment + soilSoftness * (c - currentState.sediment);
            currentState.height -= soilSoftness * (c - currentState.sediment);
            currentState.sediment = 0;
        }

        if(currentState.height > neighborState.height)
            currentState.height = neighborState. height;
    }
    
    
    
    return currentState;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int2 position = int2(id.xy);
    VertexState currentState = GetState(position);
    
    if(!IsInBounds(position))
        return;

    float heightDeltas[9];
    int heightDeltasCount = 0;
    float deltaAccumulated = 0;

    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (x == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(x, y);

            if(!IsInBounds(neighborPos))
                continue;

            VertexState neighborState = GetState(neighborPos);
            float delta = currentState.height - neighborState.height;

            deltaAccumulated += delta;
            
            ++heightDeltasCount;
            heightDeltas[x+1+(y+1)*3] = delta;
        }
    }
    
    for(int i = 0; i < 9; ++i)
        heightDeltas[i] /= deltaAccumulated;

    VertexState resultState; 
    
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (x == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(x, y);

            if(IsInBounds(neighborPos))
            {
                VertexState resultNeighborState = NeighborInteraction(heightDeltas[x+1+(y+1)*3], currentState, position, neighborPos);

                resultState.height += resultNeighborState.height / heightDeltasCount;
                resultState.sediment += resultNeighborState.sediment / heightDeltasCount;
                resultState.water += resultNeighborState.water / heightDeltasCount;

            }
        }
    }

    SetState(position, resultState);
    
    //float deposit = water * depositionRate;
    //height += deposit;
    //SetWater(position, water * (1.0 - evaporationRate));
}