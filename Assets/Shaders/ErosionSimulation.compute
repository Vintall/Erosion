#pragma kernel CSMain

struct VertexState
{
    float height;
    float water;
    float sediment;
};

StructuredBuffer<VertexState> inVertexStates;
RWStructuredBuffer<VertexState> outVertexStates;

int mapWidth;
int mapHeight;
float erosionRate;
float depositionRate;
float evaporationRate;
float sedimentCarryingCapacity;
float soilSoftness;
float minSlope;

VertexState GetState(int2 pos)
{
    return inVertexStates[pos.y * mapWidth + pos.x];
}

void SetState(int2 pos, VertexState value)
{
    outVertexStates[pos.y * mapWidth + pos.x] = value;
}

bool IsInBounds(int2 pos)
{
    return pos.x >= 0 && pos.y >= 0 && pos.x < mapWidth && pos.y < mapHeight;
}

void NeighborInteraction(int2 currentPos, int2 neighborPos, out VertexState resultCurrent, out VertexState resultNeighbor)
{
    VertexState currentState = GetState(currentPos);
    VertexState neighborState = GetState(neighborPos);
    VertexState resultState = currentState;

    float deltaWater = min(currentState.water,
    ((currentState.water + currentState.height) -
    (neighborState.water + neighborState.height)));

    if(deltaWater <= 0)
    {
        float deltaHeight = depositionRate * currentState.sediment;

        resultState.height += deltaHeight;
        resultState.sediment -= deltaHeight;

    }
    else
    {
        resultState.water -= deltaWater;
        neighborState.water += deltaWater;

        float maximumCarryingSediment = deltaWater * sedimentCarryingCapacity;

        if(currentState.sediment > maximumCarryingSediment)
        {
            neighborState.sediment += maximumCarryingSediment;
            float remainingSediment = currentState.sediment - maximumCarryingSediment;
            resultState.height += depositionRate * remainingSediment;
            resultState.sediment -= depositionRate * remainingSediment;
        }
        else
        {
            neighborState.sediment += currentState.sediment + soilSoftness * (maximumCarryingSediment - currentState.sediment);
            resultState.height -= soilSoftness * (maximumCarryingSediment - currentState.sediment);
            resultState.sediment = 0;
        }
    }

    resultCurrent = resultState;
    resultNeighbor = neighborState;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int2 position = int2(id.xy);
    VertexState currentState = GetState(position);
    
    if(!IsInBounds(position))
        return;

    float heightDeltas[9];
    int heightDeltasCount = 0;
    float deltaAccumulated = 0;

    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (x == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(x, y);

            if(!IsInBounds(neighborPos))
                continue;

            VertexState neighborState = GetState(neighborPos);
            float delta = currentState.height - neighborState.height;

            deltaAccumulated += delta;
            
            ++heightDeltasCount;
            heightDeltas[x+1+(y+1)*3] = delta;
        }
    }
    
    for(int i = 0; i < 9; ++i)
        heightDeltas[i] /= deltaAccumulated;

    VertexState resultState; 
    
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (x == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(x, y);

            if(IsInBounds(neighborPos))
            {
                VertexState resultCurrent;
                VertexState resultNeighbor;
                NeighborInteraction(position, neighborPos, resultCurrent, resultNeighbor);

                resultState.height += resultCurrent.height / heightDeltasCount;
                resultState.sediment += resultCurrent.sediment / heightDeltasCount;
                resultState.water += resultCurrent.water / heightDeltasCount;

                VertexState authenticNeighbor = GetState(neighborPos);
                
                //resultNeighbor.height = (resultNeighbor.height + authenticNeighbor.height) / 2;
                //resultNeighbor.water = (resultNeighbor.water + authenticNeighbor.water) / 2;
                //resultNeighbor.sediment = (resultNeighbor.sediment + authenticNeighbor.sediment) / 2;
                
                //SetState(neighborPos, resultNeighbor);
            }
        }
    }

    SetState(position, resultState);
    
    //float deposit = water * depositionRate;
    //height += deposit;
    //SetWater(position, water * (1.0 - evaporationRate));
}