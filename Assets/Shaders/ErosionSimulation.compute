#pragma kernel CalculateDifferences
#pragma kernel ApplyDifferences
#pragma kernel GaussianBlur

struct VertexState
{
    float height;
    float water;
    float sediment;
};

RWStructuredBuffer<VertexState> inVertexStates;
RWStructuredBuffer<VertexState> outVertexStates;

int mapWidth;
int mapHeight;
float erosionRate;
float depositionRate;
float evaporationRate;
float sedimentCarryingCapacity;
float soilSoftness;
float minSlope;
float blurCenterModifier;
float blurAdjacentModifier;
float blurDiagonalModifier;

VertexState GetState(int2 pos)
{
    return inVertexStates[pos.y * mapWidth + pos.x];
}

void SetState(int2 pos, VertexState value)
{
    outVertexStates[pos.y * mapWidth + pos.x] = value;
}

bool IsInBounds(int2 pos)
{
    return pos.x >= 0 && pos.y >= 0 && pos.x < mapWidth && pos.y < mapHeight;
}

void NeighborInteraction(int2 currentPos, int2 neighborPos, out VertexState resultCurrent, out VertexState resultNeighbor)
{
    VertexState currentState = GetState(currentPos);
    VertexState neighborState = GetState(neighborPos);
    VertexState resultState = currentState;

    float deltaWater = min(currentState.water,
    ((currentState.water + currentState.height) -
    (neighborState.water + neighborState.height)));

    if(deltaWater <= 0)
    {
        float deltaHeight = depositionRate * currentState.sediment;

        resultState.height += deltaHeight;
        resultState.sediment -= deltaHeight;

    }
    else
    {
        resultState.water -= deltaWater;
        neighborState.water += deltaWater;

        float maximumCarryingSediment = deltaWater * sedimentCarryingCapacity;

        if(currentState.sediment > maximumCarryingSediment)
        {
            neighborState.sediment += maximumCarryingSediment;
            float remainingSediment = currentState.sediment - maximumCarryingSediment;
            resultState.height += depositionRate * remainingSediment;
            resultState.sediment -= depositionRate * remainingSediment;
        }
        else
        {
            neighborState.sediment += currentState.sediment + soilSoftness * (maximumCarryingSediment - currentState.sediment);
            resultState.height -= soilSoftness * (maximumCarryingSediment - currentState.sediment);
            resultState.sediment = 0;
        }
    }

    resultCurrent = resultState;
    resultNeighbor = neighborState;
}

[numthreads(8, 8, 1)]
void CalculateDifferences(uint3 id : SV_DispatchThreadID)
{
    int2 position = int2(id.xy);
    VertexState currentState = GetState(position);
    
    if(!IsInBounds(position))
        return;

    float heightDeltas[9];
    int heightDeltasCount = 0;
    float deltaAccumulated = 0;
    
    for (int xx = -1; xx <= 1; ++xx)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (xx == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(xx, y);

            if(!IsInBounds(neighborPos))
                continue;

            VertexState neighborState = GetState(neighborPos);
            float delta = currentState.height - neighborState.height;
            
            deltaAccumulated += delta;
            
            ++heightDeltasCount;
            heightDeltas[xx+1+(y+1)*3] = delta;
        }
    } 
    
    for(int i = 0; i < 9; ++i)
        heightDeltas[i] /= deltaAccumulated;

    VertexState resultState; 
    
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            if (x == 0 && y == 0)
                continue;

            int2 neighborPos = position + int2(x, y);

            if(IsInBounds(neighborPos))
            {
                VertexState resultCurrent;
                VertexState resultNeighbor;
                NeighborInteraction(position, neighborPos, resultCurrent, resultNeighbor);

                resultState.height += resultCurrent.height / heightDeltasCount;
                resultState.sediment += resultCurrent.sediment / heightDeltasCount;
                resultState.water += resultCurrent.water / heightDeltasCount;

                VertexState authenticNeighbor = GetState(neighborPos);
            }
        }
    }

    SetState(position, resultState);
}

[numthreads(8, 8, 1)]
void ApplyDifferences(uint3 id : SV_DispatchThreadID)
{
    int2 position = int2(id.xy);
    float2 uv = float2((float)position.x / mapWidth, (float)position.y / mapHeight);

    inVertexStates[position.y * mapWidth + position.x] =
        outVertexStates[position.y * mapWidth + position.x];
}

[numthreads(8, 8, 1)]
void GaussianBlur(uint3 id : SV_DispatchThreadID)
{
    int2 position = int2(id.xy);

    if(position.x == 0 || position.x == mapWidth - 1)
        return;

    if(position.y == 0 || position.y == mapHeight - 1)
        return;

    inVertexStates[position.y * mapWidth + position.x].height = 
                        inVertexStates[position.y * mapWidth + position.x].height * blurCenterModifier +
                        inVertexStates[position.y * mapWidth + position.x + 1].height * blurAdjacentModifier +
                        inVertexStates[(position.y + 1) * mapWidth + position.x].height * blurAdjacentModifier +
                        inVertexStates[position.y * mapWidth + position.x - 1].height * blurAdjacentModifier +
                        inVertexStates[(position.y - 1) * mapWidth + position.x].height * blurAdjacentModifier +
                        inVertexStates[(position.y + 1) * mapWidth + position.x + 1].height * blurDiagonalModifier +
                        inVertexStates[(position.y + 1) * mapWidth + position.x - 1].height * blurDiagonalModifier +
                        inVertexStates[(position.y - 1) * mapWidth + position.x + 1].height * blurDiagonalModifier +
                        inVertexStates[(position.y - 1) * mapWidth + position.x - 1].height * blurDiagonalModifier;
}